chapter_id,chapter_name,section_id,section_name,req_id,req_description,L
V1,Encoding and Sanitization,V1.2,Injection Prevention,V1.2.1,"Verify that output encoding for an HTTP response, HTML document, or XML document is relevant for the context required, such as encoding the relevant characters for HTML elements, HTML attributes, HTML comments, CSS, or HTTP header fields, to avoid changing the message or document structure.",1
V1,Encoding and Sanitization,V1.2,Injection Prevention,V1.2.2,"Verify that when dynamically building URLs, untrusted data is encoded according to its context (e.g., URL encoding or base64url encoding for query or path parameters). Ensure that only safe URL protocols are permitted (e.g., disallow javascript: or data:).",1
V1,Encoding and Sanitization,V1.2,Injection Prevention,V1.2.3,"Verify that output encoding or escaping is used when dynamically building JavaScript content (including JSON), to avoid changing the message or document structure (to avoid JavaScript and JSON injection).",1
V1,Encoding and Sanitization,V1.2,Injection Prevention,V1.2.4,"Verify that data selection or database queries (e.g., SQL, HQL, NoSQL, Cypher) use parameterized queries, ORMs, entity frameworks, or are otherwise protected from SQL Injection and other database injection attacks. This is also relevant when writing stored procedures.",1
V1,Encoding and Sanitization,V1.2,Injection Prevention,V1.2.5,Verify that the application protects against OS command injection and that operating system calls use parameterized OS queries or use contextual command line output encoding.,1
V1,Encoding and Sanitization,V1.3,Sanitization,V1.3.1,Verify that all untrusted HTML input from WYSIWYG editors or similar is sanitized using a well-known and secure HTML sanitization library or framework feature.,1
V1,Encoding and Sanitization,V1.3,Sanitization,V1.3.2,"Verify that the application avoids the use of eval() or other dynamic code execution features such as Spring Expression Language (SpEL). Where there is no alternative, any user input being included must be sanitized before being executed.",1
V1,Encoding and Sanitization,V1.5,Safe Deserialization,V1.5.1,Verify that the application configures XML parsers to use a restrictive configuration and that unsafe features such as resolving external entities are disabled to prevent XML eXternal Entity (XXE) attacks.,1
V2,Validation and Business Logic,V2.1,Validation and Business Logic Documentation,V2.1.1,"Verify that the application's documentation defines input validation rules for how to check the validity of data items against an expected structure. This could be common data formats such as credit card numbers, email addresses, telephone numbers, or it could be an internal data format.",1
V2,Validation and Business Logic,V2.2,Input Validation,V2.2.1,"Verify that input is validated to enforce business or functional expectations for that input. This should either use positive validation against an allow list of values, patterns, and ranges, or be based on comparing the input to an expected structure and logical limits according to predefined rules. For L1, this can focus on input which is used to make specific business or security decisions. For L2 and up, this should apply to all input.",1
V2,Validation and Business Logic,V2.2,Input Validation,V2.2.2,"Verify that the application is designed to enforce input validation at a trusted service layer. While client-side validation improves usability and should be encouraged, it must not be relied upon as a security control.",1
V2,Validation and Business Logic,V2.3,Business Logic Security,V2.3.1,Verify that the application will only process business logic flows for the same user in the expected sequential step order and without skipping steps.,1
V3,Web Frontend Security,V3.2,Unintended Content Interpretation,V3.2.1,"Verify that security controls are in place to prevent browsers from rendering content or functionality in HTTP responses in an incorrect context (e.g., when an API, a user-uploaded file or other resource is requested directly). Possible controls could include: not serving the content unless HTTP request header fields (such as Sec-Fetch-\*) indicate it is the correct context, using the sandbox directive of the Content-Security-Policy header field or using the attachment disposition type in the Content-Disposition header field.",1
V3,Web Frontend Security,V3.2,Unintended Content Interpretation,V3.2.2,"Verify that content intended to be displayed as text, rather than rendered as HTML, is handled using safe rendering functions (such as createTextNode or textContent) to prevent unintended execution of content such as HTML or JavaScript.",1
V3,Web Frontend Security,V3.3,Cookie Setup,V3.3.1,"Verify that cookies have the 'Secure' attribute set, and if the '\__Host-' prefix is not used for the cookie name, the '__Secure-' prefix must be used for the cookie name.",1
V3,Web Frontend Security,V3.4,Browser Security Mechanism Headers,V3.4.1,"Verify that a Strict-Transport-Security header field is included on all responses to enforce an HTTP Strict Transport Security (HSTS) policy. A maximum age of at least 1 year must be defined, and for L2 and up, the policy must apply to all subdomains as well.",1
V3,Web Frontend Security,V3.4,Browser Security Mechanism Headers,V3.4.2,"Verify that the Cross-Origin Resource Sharing (CORS) Access-Control-Allow-Origin header field is a fixed value by the application, or if the Origin HTTP request header field value is used, it is validated against an allowlist of trusted origins. When 'Access-Control-Allow-Origin: *' needs to be used, verify that the response does not include any sensitive information.",1
V3,Web Frontend Security,V3.5,Browser Origin Separation,V3.5.1,"Verify that, if the application does not rely on the CORS preflight mechanism to prevent disallowed cross-origin requests to use sensitive functionality, these requests are validated to ensure they originate from the application itself. This may be done by using and validating anti-forgery tokens or requiring extra HTTP header fields that are not CORS-safelisted request-header fields. This is to defend against browser-based request forgery attacks, commonly known as cross-site request forgery (CSRF).",1
V3,Web Frontend Security,V3.5,Browser Origin Separation,V3.5.2,"Verify that, if the application relies on the CORS preflight mechanism to prevent disallowed cross-origin use of sensitive functionality, it is not possible to call the functionality with a request which does not trigger a CORS-preflight request. This may require checking the values of the 'Origin' and 'Content-Type' request header fields or using an extra header field that is not a CORS-safelisted header-field.",1
V3,Web Frontend Security,V3.5,Browser Origin Separation,V3.5.3,"Verify that HTTP requests to sensitive functionality use appropriate HTTP methods such as POST, PUT, PATCH, or DELETE, and not methods defined by the HTTP specification as ""safe"" such as HEAD, OPTIONS, or GET. Alternatively, strict validation of the Sec-Fetch-* request header fields can be used to ensure that the request did not originate from an inappropriate cross-origin call, a navigation request, or a resource load (such as an image source) where this is not expected.",1
V4,API and Web Service,V4.1,Generic Web Service Security,V4.1.1,"Verify that every HTTP response with a message body contains a Content-Type header field that matches the actual content of the response, including the charset parameter to specify safe character encoding (e.g., UTF-8, ISO-8859-1) according to IANA Media Types, such as ""text/"", ""/+xml"" and ""/xml"".",1
V4,API and Web Service,V4.4,WebSocket,V4.4.1,Verify that WebSocket over TLS (WSS) is used for all WebSocket connections.,1
V5,File Handling,V5.2,File Upload and Content,V5.2.1,Verify that the application will only accept files of a size which it can process without causing a loss of performance or a denial of service attack.,1
V5,File Handling,V5.2,File Upload and Content,V5.2.2,"Verify that when the application accepts a file, either on its own or within an archive such as a zip file, it checks if the file extension matches an expected file extension and validates that the contents correspond to the type represented by the extension. This includes, but is not limited to, checking the initial 'magic bytes', performing image re-writing, and using specialized libraries for file content validation. For L1, this can focus just on files which are used to make specific business or security decisions. For L2 and up, this must apply to all files being accepted.",1
V5,File Handling,V5.3,File Storage,V5.3.1,"Verify that files uploaded or generated by untrusted input and stored in a public folder, are not executed as server-side program code when accessed directly with an HTTP request.",1
V5,File Handling,V5.3,File Storage,V5.3.2,"Verify that when the application creates file paths for file operations, instead of user-submitted filenames, it uses internally generated or trusted data, or if user-submitted filenames or file metadata must be used, strict validation and sanitization must be applied. This is to protect against path traversal, local or remote file inclusion (LFI, RFI), and server-side request forgery (SSRF) attacks.",1
V6,Authentication,V6.1,Authentication Documentation,V6.1.1,"Verify that application documentation defines how controls such as rate limiting, anti-automation, and adaptive response, are used to defend against attacks such as credential stuffing and password brute force. The documentation must make clear how these controls are configured and prevent malicious account lockout.",1
V6,Authentication,V6.2,Password Security,V6.2.1,Verify that user set passwords are at least 8 characters in length although a minimum of 15 characters is strongly recommended.,1
V6,Authentication,V6.2,Password Security,V6.2.2,Verify that users can change their password.,1
V6,Authentication,V6.2,Password Security,V6.2.3,Verify that password change functionality requires the user's current and new password.,1
V6,Authentication,V6.2,Password Security,V6.2.4,"Verify that passwords submitted during account registration or password change are checked against an available set of, at least, the top 3000 passwords which match the application's password policy, e.g. minimum length.",1
V6,Authentication,V6.2,Password Security,V6.2.5,"Verify that passwords of any composition can be used, without rules limiting the type of characters permitted. There must be no requirement for a minimum number of upper or lower case characters, numbers, or special characters.",1
V6,Authentication,V6.2,Password Security,V6.2.6,"Verify that password input fields use type=password to mask the entry. Applications may allow the user to temporarily view the entire masked password, or the last typed character of the password.",1
V6,Authentication,V6.2,Password Security,V6.2.7,"Verify that ""paste"" functionality, browser password helpers, and external password managers are permitted.",1
V6,Authentication,V6.2,Password Security,V6.2.8,"Verify that the application verifies the user's password exactly as received from the user, without any modifications such as truncation or case transformation.",1
V6,Authentication,V6.3,General Authentication Security,V6.3.1,Verify that controls to prevent attacks such as credential stuffing and password brute force are implemented according to the application's security documentation.,1
V6,Authentication,V6.3,General Authentication Security,V6.3.2,"Verify that default user accounts (e.g., ""root"", ""admin"", or ""sa"") are not present in the application or are disabled.",1
V6,Authentication,V6.4,Authentication Factor Lifecycle and Recovery,V6.4.1,"Verify that system generated initial passwords or activation codes are securely randomly generated, follow the existing password policy, and expire after a short period of time or after they are initially used. These initial secrets must not be permitted to become the long term password.",1
V6,Authentication,V6.4,Authentication Factor Lifecycle and Recovery,V6.4.2,"Verify that password hints or knowledge-based authentication (so-called ""secret questions"") are not present.",1
V7,Session Management,V7.2,Fundamental Session Management Security,V7.2.1,"Verify that the application performs all session token verification using a trusted, backend service.",1
V7,Session Management,V7.2,Fundamental Session Management Security,V7.2.2,"Verify that the application uses either self-contained or reference tokens that are dynamically generated for session management, i.e. not using static API secrets and keys.",1
V7,Session Management,V7.2,Fundamental Session Management Security,V7.2.3,"Verify that if reference tokens are used to represent user sessions, they are unique and generated using a cryptographically secure pseudo-random number generator (CSPRNG) and possess at least 128 bits of entropy.",1
V7,Session Management,V7.2,Fundamental Session Management Security,V7.2.4,"Verify that the application generates a new session token on user authentication, including re-authentication, and terminates the current session token.",1
V7,Session Management,V7.4,Session Termination,V7.4.1,"Verify that when session termination is triggered (such as logout or expiration), the application disallows any further use of the session. For reference tokens or stateful sessions, this means invalidating the session data at the application backend. Applications using self-contained tokens will need a solution such as maintaining a list of terminated tokens, disallowing tokens produced before a per-user date and time or rotating a per-user signing key.",1
V7,Session Management,V7.4,Session Termination,V7.4.2,Verify that the application terminates all active sessions when a user account is disabled or deleted (such as an employee leaving the company).,1
V8,Authorization,V8.1,Authorization Documentation,V8.1.1,Verify that authorization documentation defines rules for restricting function-level and data-specific access based on consumer permissions and resource attributes.,1
V8,Authorization,V8.2,General Authorization Design,V8.2.1,Verify that the application ensures that function-level access is restricted to consumers with explicit permissions.,1
V8,Authorization,V8.2,General Authorization Design,V8.2.2,Verify that the application ensures that data-specific access is restricted to consumers with explicit permissions to specific data items to mitigate insecure direct object reference (IDOR) and broken object level authorization (BOLA).,1
V8,Authorization,V8.3,Operation Level Authorization,V8.3.1,"Verify that the application enforces authorization rules at a trusted service layer and doesn't rely on controls that an untrusted consumer could manipulate, such as client-side JavaScript.",1
V9,Self-contained Tokens,V9.1,Token source and integrity,V9.1.1,Verify that self-contained tokens are validated using their digital signature or MAC to protect against tampering before accepting the token's contents.,1
V9,Self-contained Tokens,V9.1,Token source and integrity,V9.1.2,"Verify that only algorithms on an allowlist can be used to create and verify self-contained tokens, for a given context. The allowlist must include the permitted algorithms, ideally only either symmetric or asymmetric algorithms, and must not include the 'None' algorithm. If both symmetric and asymmetric must be supported, additional controls will be needed to prevent key confusion.",1
V9,Self-contained Tokens,V9.1,Token source and integrity,V9.1.3,"Verify that key material that is used to validate self-contained tokens is from trusted pre-configured sources for the token issuer, preventing attackers from specifying untrusted sources and keys. For JWTs and other JWS structures, headers such as 'jku', 'x5u', and 'jwk' must be validated against an allowlist of trusted sources.",1
V9,Self-contained Tokens,V9.2,Token content,V9.2.1,"Verify that, if a validity time span is present in the token data, the token and its content are accepted only if the verification time is within this validity time span. For example, for JWTs, the claims 'nbf' and 'exp' must be verified.",1
V10,OAuth and OIDC,V10.4,OAuth Authorization Server,V10.4.1,Verify that the authorization server validates redirect URIs based on a client-specific allowlist of pre-registered URIs using exact string comparison.,1
V10,OAuth and OIDC,V10.4,OAuth Authorization Server,V10.4.2,"Verify that, if the authorization server returns the authorization code in the authorization response, it can be used only once for a token request. For the second valid request with an authorization code that has already been used to issue an access token, the authorization server must reject a token request and revoke any issued tokens related to the authorization code.",1
V10,OAuth and OIDC,V10.4,OAuth Authorization Server,V10.4.3,Verify that the authorization code is short-lived. The maximum lifetime can be up to 10 minutes for L1 and L2 applications and up to 1 minute for L3 applications.,1
V10,OAuth and OIDC,V10.4,OAuth Authorization Server,V10.4.4,"Verify that for a given client, the authorization server only allows the usage of grants that this client needs to use. Note that the grants 'token' (Implicit flow) and 'password' (Resource Owner Password Credentials flow) must no longer be used.",1
V10,OAuth and OIDC,V10.4,OAuth Authorization Server,V10.4.5,"Verify that the authorization server mitigates refresh token replay attacks for public clients, preferably using sender-constrained refresh tokens, i.e., Demonstrating Proof of Possession (DPoP) or Certificate-Bound Access Tokens using mutual TLS (mTLS). For L1 and L2 applications, refresh token rotation may be used. If refresh token rotation is used, the authorization server must invalidate the refresh token after usage, and revoke all refresh tokens for that authorization if an already used and invalidated refresh token is provided.",1
V11,Cryptography,V11.3,Encryption Algorithms,V11.3.1,"Verify that insecure block modes (e.g., ECB) and weak padding schemes (e.g., PKCS#1 v1.5) are not used.",1
V11,Cryptography,V11.3,Encryption Algorithms,V11.3.2,Verify that only approved ciphers and modes such as AES with GCM are used.,1
V11,Cryptography,V11.4,Hashing and Hash-based Functions,V11.4.1,"Verify that only approved hash functions are used for general cryptographic use cases, including digital signatures, HMAC, KDF, and random bit generation. Disallowed hash functions, such as MD5, must not be used for any cryptographic purpose.",1
V12,Secure Communication,V12.1,General TLS Security Guidance,V12.1.1,"Verify that only the latest recommended versions of the TLS protocol are enabled, such as TLS 1.2 and TLS 1.3. The latest version of the TLS protocol must be the preferred option.",1
V12,Secure Communication,V12.2,HTTPS Communication with External Facing Services,V12.2.1,"Verify that TLS is used for all connectivity between a client and external facing, HTTP-based services, and does not fall back to insecure or unencrypted communications.",1
V12,Secure Communication,V12.2,HTTPS Communication with External Facing Services,V12.2.2,Verify that external facing services use publicly trusted TLS certificates.,1
V13,Configuration,V13.4,Unintended Information Leakage,V13.4.1,"Verify that the application is deployed either without any source control metadata, including the .git or .svn folders, or in a way that these folders are inaccessible both externally and to the application itself.",1
V14,Data Protection,V14.2,General Data Protection,V14.2.1,"Verify that sensitive data is only sent to the server in the HTTP message body or header fields, and that the URL and query string do not contain sensitive information, such as an API key or session token.",1
V14,Data Protection,V14.3,Client-side Data Protection,V14.3.1,"Verify that authenticated data is cleared from client storage, such as the browser DOM, after the client or session is terminated. The 'Clear-Site-Data' HTTP response header field may be able to help with this but the client-side should also be able to clear up if the server connection is not available when the session is terminated.",1
V15,Secure Coding and Architecture,V15.1,Secure Coding and Architecture Documentation,V15.1.1,"Verify that application documentation defines risk based remediation time frames for 3rd party component versions with vulnerabilities and for updating libraries in general, to minimize the risk from these components.",1
V15,Secure Coding and Architecture,V15.2,Security Architecture and Dependencies,V15.2.1,Verify that the application only contains components which have not breached the documented update and remediation time frames.,1
V15,Secure Coding and Architecture,V15.3,Defensive Coding,V15.3.1,"Verify that the application only returns the required subset of fields from a data object. For example, it should not return an entire data object, as some individual fields should not be accessible to users.",1
